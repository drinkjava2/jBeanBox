关于@Named的定义和使用
@COMPONENT("servImpl")
public class ServImpl implements Serv{}
= 
bind("servImpl", getBeanBox(ServImpl.class)); 

或  
@COMPONENT  //缺省名如果前两个都大写，则首字母还是大写。
@NAMED("someName") //与第一种有细微区别，这个是Qualifier,并不是bean的名字
public class ServImpl implements Serv{}
=
bind("servImpl", getBeanBox(ServImpl.class).setQualifierClass(Named.class).setQualifierValue("someName"));
 
使用:
@INJECT
@NAMED("servImpl");
Serv serv;
或
Serv serv=getBean("servImpl") //仅限于bean有名字用法
或
Serv serv=getBean(Serv.class, Named.class,"servImpl") //限于bean有name或@Named注解
 

关于@Qualifier的定义和使用
(实际上@Named只是@Qualifier的一个特例，相当于value字段为字符串类型值)
@COMPONENT
@MyQuali(MyColor.RED)
public class ServImpl implements Serv{} 
=
bind("servImpl", getBeanBox(ServImpl.class).setQualifierClass(MyQuali.class).setQualifierValue(MyColor.RED));


使用
@Inject
@MyQuali(Color.RED)
Serv a;
或
Serv serv=getBean(Serv.class, MyQuali.class,  MyColor.RED) //限于bean有@Named注解
  

在遇到@Inject的时候，比如要注入Serv serv，要在原有规则上，增加以下规则：
1.如果Component存在, 检查是否存在待注入类的本身或子类component， 给待注入类作个标记，以后标记为NON-EXIST-COMPONENT的不再从component中搜索
2.检查找到结果的Qualifier，如果符合就使用它
















* 如果是@Inject或getBean(Xxxx.class):
    先看bind里有没有Xxxx.class主键，如有使用bind里的target 
    在所有bind值里找BeanBox类型的beanClass是子类的，
        如找到1个或primary, 在bind里绑定它bind(xxx.class, xxxBox)
        如找到多个子类，报错
        如找不到, 创建box，还是在bind里绑定它bind(Xxx.class, xxxBox)

*  如果是@Inject() @Named:  或 
先在bind里找，然后在component里找，相同Named标记的类或子类
 
2.如果在component中有这个类：
     componentCache里找有没有
3.如果在component中没有这个类，正常获取它的BeanBox，生成bean返回
 
 